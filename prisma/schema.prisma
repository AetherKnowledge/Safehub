generator client {
  provider      = "prisma-client-js"
  output        = "../app/generated/prisma"
  binaryTargets = ["native", "windows", "debian-openssl-3.0.x", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserType {
  Student
  Counselor
  Admin
}

enum AppointmentStatus {
  Approved
  Pending
  Completed
  Rejected
}

enum Days {
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}

enum ChatType {
  GROUP
  DIRECT
}

enum CallStatus {
  Pending
  Accepted
  Rejected
  Ended
  No_Answer
}

enum UserStatus {
  Online
  Offline
}

enum SessionPreference {
  InPerson
  Online
  Either
}

model User {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String?
  email         String    @unique
  password      String?
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]

  firstName     String?
  lastName      String?
  department    String?
  program       String?
  year          Int?
  section       String?
  recoveryEmail String?
  phoneNumber   String?

  darkMode Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type   UserType   @default(Student)
  status UserStatus @default(Offline)

  chatHistory chathistory[]

  Student   Student?
  Counselor Counselor?
  Admin     Admin?

  chatMembers ChatMember[]
  messages    ChatMessage[]

  call       Call[]
  callMember CallMember[]

  posts    Post[]
  likes    Like[]
  dislikes Dislike[]
  comments Comment[]
}

model Student {
  studentId    String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user         User          @relation(fields: [studentId], references: [id], onDelete: Cascade)
  appointments Appointment[]
}

model Counselor {
  counselorId    String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user           User            @relation(fields: [counselorId], references: [id], onDelete: Cascade)
  appointments   Appointment[]
  available      Boolean         @default(false)
  AvailableSlots AvailableSlot[]
}

model Admin {
  adminId String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user    User   @relation(fields: [adminId], references: [id], onDelete: Cascade)
}

model Chat {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type          ChatType @default(DIRECT)
  name          String?
  description   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastMessageAt DateTime @default(now())
  call          Call?

  members  ChatMember[]
  messages ChatMessage[]
}

model ChatMember {
  id       String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chatId   String   @db.Uuid
  userId   String   @db.Uuid
  joinedAt DateTime @default(now())

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
}

model ChatMessage {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chatId    String   @db.Uuid
  userId    String   @db.Uuid
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Call {
  id        String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chatId    String     @unique @db.Uuid
  status    CallStatus @default(Pending)
  createdAt DateTime   @default(now())
  callerId  String     @db.Uuid

  chat   Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  caller User @relation(fields: [callerId], references: [id], onDelete: Cascade)

  callMember CallMember[]
}

model CallMember {
  id       String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  socketId String
  callId   String   @db.Uuid
  userId   String   @db.Uuid
  joinedAt DateTime @default(now())

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([callId, userId])
}

model AvailableSlot {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  counselorId String @db.Uuid
  day         Days
  startTime   String
  endTime     String

  counselor Counselor @relation(fields: [counselorId], references: [counselorId], onDelete: Cascade)
}

model Post {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title     String
  content   String?
  authorId  String   @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  images    String[] @db.VarChar(255)

  likes    Like[]
  dislikes Dislike[]
  comments Comment[]

  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model Like {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId    String   @db.Uuid
  userId    String   @db.Uuid
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
}

model Dislike {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId    String   @db.Uuid
  userId    String   @db.Uuid
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
}

model Comment {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId    String   @db.Uuid
  userId    String   @db.Uuid
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model chathistory {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id String   @db.Uuid
  message    Json
  createdAt  DateTime @default(now())

  user User @relation(fields: [session_id], references: [id], onDelete: Cascade)
}

model Appointment {
  id          String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  studentId   String            @db.Uuid
  counselorId String            @db.Uuid
  status      AppointmentStatus @default(Pending)
  createdAt   DateTime          @default(now())

  focus               String
  hadCounselingBefore Boolean
  sessionPreference   SessionPreference
  urgencyLevel        Int
  startTime           DateTime
  endTime             DateTime?
  notes               String?
  room                String?

  student   Student   @relation(fields: [studentId], references: [studentId], onDelete: Cascade)
  counselor Counselor @relation(fields: [counselorId], references: [counselorId], onDelete: Cascade)
  feedback  Feedback?
}

model Feedback {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  appointmentId String   @unique @db.Uuid
  rating        Int
  content       String?
  isAnonymous   Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
}

model Account {
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId       String   @db.Uuid
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}
